## 1주차 큐/스택

### 개념
 - #### 큐
	- 선입선출(FIFO) 방식의 자료구조
 - #### 스택
	- 후입선출(LIFO) 방식의 자료구조

### 활용 가능한 C++ STL
 - #### std::array
 - #### std::vector
 - #### std::list
 - #### std::deque
 
`std::queue`와 `std::stack` 자료구조 사용이 가능하나 기본적인 것들을 짚고 간다.

#### std::array
 - C 스타일의 __배열__ 과 유사하게 동작한다.
 - 모든 원소에 대해 임의 접근 동작이 O(1) 시간 복잡도를 갖는다.
 - 원소 삽입/삭제 시 원소의 이동이 필요하여 O(n) 시간 복잡도를 갖는다.

 - #### 단점
	- 크기가 컴파일 시간에 결정되는 상수이어야 한다.
	- array 크기를 넘어서 원소를 추가하거나 삭제할 수 없다.
	- 메모리 할당 방법을 변경할 수 없으며 항상 스택 메모리를 사용한다.
	
#### std::vector
 - 가변 크기 배열
 - 초기화 시 용량(capacity)을 할당 받음

 - push_back(val) 동작 과정
``` c++
push_back(val)
  // 새 원소 추가할 공간이 있는 경우
  if ( size < capacity )
	- 마지막 원소 다음에 val 저장
	- 벡터 크기를 1만큼 증가
	- return
  
  // 할당한 메모리 공간이 가득 차 있는 경우
  if ( vector is already full )
    - 2*size 크기의 메모리를 새로 할당
	- 새로 할당한 메모리로 기존 원소 전부를 복사/이동
	- 데이터 포인터를 새로 할당한 메모리 주소로 지정
	- 마지막 원소 다음에 val을 저장하고, 벡터 크기를 1만큼 증가
```
`push_back()`에서 공간이 충분하지 않은 경우에 O(n)의 시간 복잡도가 걸리나 이 경우는 흔하지 않으니 평균 O(1) 시간 복잡도를 갖는다.

#### std::list
 - 이중 연결 리스트
 - 보통 `data`, `prev_node`, `next_node` 형태를 갖는다.
 - 원소 삽입/삭제의 시간 복잡도가 O(1)이다.
 
 - #### 맴버 함수 종류
	- sort() : 오름차순 정렬 // O(nlogn)
	- reverse() : 저장된 원소의 순서를 역순으로 변경 // O(n)
	- unique() : 중복된걸 첫 원소 남기고 전부 삭제
	
 - 반복자를 무효화하지 않는다. 
	- `vector`의 경우 __메모리 재할당__ 시 반복자가 가리키는 주소 공간이 바뀌어 __반복자 무효화__ 가 일어나는데 `list`의 경우 __메모리 재할당__ 이 일어나지 않기에 __반복자 무효화__ 는 일어나지 않는다.

#### std::deque
 - 앞 뒤로 원소 추가/삭제가 가능한 자료구조
 - __덱__ 의 구조는 배열 또는 벡터와 유사하다.
 - 단일 메모리 청크를 사용하지 않는다.
 
 - C++ 에서의 `deque` 조건
	- push, pop 동작이 O(1) 시간 복잡도를 가져야 한다
	- 모든 원소에 대해 임의 접근 동작이 O(1) 시간 복잡도로 동작
	- 덱 중간에서 원소 삽입/삭제 O(n) 시간 복잡도로 동작 // 실제론 최대 n/2 단계로 동작 (n은 덱의 크기)